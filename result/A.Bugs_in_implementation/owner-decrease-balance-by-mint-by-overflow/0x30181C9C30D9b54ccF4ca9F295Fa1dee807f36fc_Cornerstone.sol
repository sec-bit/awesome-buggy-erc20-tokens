/*

    ,----..      
   /   /   \            *********************************
  /   .     :           *Qwoyn Digital Investments, LLC *
 .   /   ;.  \          *Cornerstone version 0.1        *
.   ;   /  ` ;          *Daniel Pittman, CEO            *
;   |  ; \ ; |          *December 2017                  *
|   :  | ; | '          *********************************
.   |  ' ' ' :   
'   ;  \; /  |   
 \   \  ',  . \  
  ;   :      ; | 
   \   \ .'`--" 


Tokenized Company Equity Right Transfer Agreement



Subject to an existing Right of Ownership Token Transfer Agreement or otherwise proclaimed possession of ownership of the underlying 

asset ("the Company Equity"), referenced hereafter as "P003_25793", Qwoyn Digital Investments, LLC, (hereafter the “Token Issuer”) 

(the “Purchaser” or the “lien holder”) hereby agrees to tokenize his ownership of  the Company Equity Right granted under the 

Agreement P003_25793, (the “Tokenized Right to Company Equity Revenue”). 

Uploading this Agreement on the blockchain will be hashed and referred in code of a Smart Contract generated by the Token Issuer. 

1. SALE OF THE TOKENIZED RIGHT. 

1.1. The Token Issuer hereby agrees to issue 1000000 Token(s) at the price of as .1 ether 2017-12-06 on the blockchain of the Token 

Issuer’s choice (Ethereum). 

1.2  The Token Issuer hereby reserves the right to issue more tokens dependent on market demand.

2. TOKEN BUYER’S PAYMENT AS CONDITION PRECEDENT. 

2.1. Token Buyer’s (defined in Section 14) payment for the Token(s) issued by Token Issuer under Section 1 is a condition precedent to 

the formation of this Agreement. There will no binding Agreement until the payment from the Token Buyer is appeared in the Token 

Issuer’s ethereum-wallet account. 

2.2. Likewise, there will be no binding agreement with any subsequent token buyer unless the payment for the Token created hereunder 

made to the Token Holder at the moment of selling the Token. 

3. SMART CONTRACT. For the purpose of recording the ownership of the Company Equity Right created under the Agreement P003_25793, 

Token Issuer generates a Smart Contract. This Smart Contract facilitates the direct transfer of the Company Equity Right created to an 

individual or an entity that makes the payment for the Token representing the ownership of the Company Equity Right created under the 

Agreement K003-2017 (the “Token Holder”). 

4. TOKEN HOLDER’S RIGHT. 

4.1. Subject to the Agreement P003_25793, all Token Holder(s) will be granted the right to set a new price for the purchased token 

hereunder, provided that he/she cannot interfere or enforce in the Company Equity Owner’s decision regarding the Company Equity 

subject to the Agreement P003_25793. 

4.2. Subject to the Agreement P003_25793, Token Holder(s)’s Company Equity Right does not create any type of a lien on the Company 

Equity subject to the Agreement P003_25793. Token Holder’s Company Equity Right will be limited to the Right to claim the amount of 

the Company Equity Income promised by the Company Equity Owner to Token Issuer under the Agreement P003_25793. 

5. RIGHT OWNER’S WARRANTIES AND DUTIES. Token Issuer and subsequent Token Holder hereby represent and warrant that, to the best of 

his/her knowledge, he/she is the sole lawful owner of the tokenized Company Equity Right created under the Agreement P003_25793 and 

free and clear of any liens and encumbrances except the ones disclosed to Token Issuer from the Company Equity Owner under the 

Agreement P003_25793. Token Issuer and each subsequent Token Holder(s) have full right, power and authority to sell and transfer 

his/her Right created under the Agreement P003_25793. Token Issuer and each subsequent Token Holder also warrant that he/she does not 

currently know of and has no reason to know of any third party claim to any right, title, or use of the Right created under the 

Agreement P003_25793 except the ones disclosed to Token Issuer from the Company Equity Owner under the Agreement P003_25793. Token 

Issuer and each subsequent Token Holder did not and will not execute any agreement in conflict with this Agreement. Once a token 

purchaser makes the full payment pursuant to Section 1, Token Issuer will take any actions that may be necessary or desirable to 

protect and perfect the Purchaser’s Company Equity Right created under the Agreement P003_25793. 

6. ASSUMPTION OF RISK. 

Each Token Holder bears the risk of loss when purchasing a Token representing the ownership of the Company Equity Right created under 

the Agreement P003_25793. Token Issuer will not be responsible for and will not be liable for any loss arising from: (a) failure or 

malfunction of hardware, software, server, and internet connections; (b) malicious software introduction; (c) the third party may 

obtain unauthorized access to information stored within buyer’s account, including, but not limited to Buyer’s storage address and 

private key; (d) forgotten passwords; and (e) incorrectly constructed transactions or mistyped account address. 

7. DISCLAIMER.

This Tokenized Company Equity Right subject to the Agreement P003_25793 is not a consumer good and sold on an “as is” and 

“as-available” basis. Token Holder(s) bears the entire risk, Token Issuer sells the tokenized Company Equity Right to Token Holder(s) 

without any warranty of fitness for a particular purpose, and Token Holder(s) acknowledges that no warrant of fitness could be offered

because of the many future technical and legal uncertainties regarding the Tokenized Company Equity Right. 

8. TAX.

Token Issuer is not responsible for any taxes or any other costs related to purchasing the Tokenized Company Equity Right created 

under the Agreement P003_25793. 

9. NO DAMAGES.

Token Issuer will never be liable to Token Holder(s) for consequential and any kind of damages, including but not limited to lost 

profits. 

10. MARKET RISK.

All Token Holder(s) understands that this Tokenized Company Equity Right is a new and relatively untested exchange medium. Token 

Holder(s) therefore understands that Token Issuer cannot predict how the value of the Tokenized Right will change, the consumer 

demand for the Tokenized Right, technical difficulties in or modification to the peer-to-peer blockchain network, change of 

regulations, and all other obstacles that a peer-to-peer blockchain network might face. All Token Holder(s) affirmatively represents 

that he/she is a sophisticated blockchain users and therefore knowingly assumes all known and unknown risk of loss. All Token Holder(s)

has not recourse whatsoever against Token Issuer for damages or liability suffered by Token Holder(s) due to the market condition or 

whatsoever causes. 

11. RISK OF FINANCIAL REGULATION.

All Token Holder(s) understands that the Tokenized Company Equity Right is a relatively new technology and no one can predict how the 

government for each country may apply and enforce the existing laws or regulate the Tokenized Right or other peer-to-peer blockchain 

based exchange technologies in the future. All Token Holder(s) understands that there is a high level of uncertainty, and all Token 

Holder(s) assumes that all financial regulatory risk inherent in operating and transferring the Tokenized Right. 

All Token Holder(s) has no recourse whatsoever against Token Issuer for damages, civil and criminal, suffered by each Token Holder(s) 

due to regulatory enforcement. Token Issuer does not and cannot warrant that the exercise or transfer of the Tokenized Company Equity 

Right is legal in all specific jurisdiction of each country. Token Issuer has not duty to advise or warn to each Token Holder(s) and 

each Token Holder(s) will not advise or warn Token Issuer about any particular legal or regulatory requirement(s). Each Token Holder(s)

is solely obligated to understand the laws and regulations of its local jurisdiction before exercising, selling, or purchasing the 

Tokenized Right, and Token Holder(s) is solely responsible for any of its actions that may be unlawful. 

12. DEFINITIONS. 

“Tokenized Right to Company Equity Revenue” means a digitized portion or unit of the syndicated ownership of the Company Equity Right 

created under the Agreement P003_25793. “Token Holder(s)” means a buyer(s) of the tokenized Right representing an ownership of the 

Company Equity Right through the Smart Contract created by the Token Issuer hereunder. “Smart Contract” means terms and conditions 

for a legally effective Instrument written in programming language or asset protocol into the blockchain of Token Issuer’s choice. 

“Token Buyer” means that a party (an individual, legal entity, or authorized person representing an organization) that intends to buy 

the Tokenized Company Equity Right initially issued by Token Issuer hereunder. 

13. DISPUTE RESOLTUION.

Informal Resolution. If either Token Issuer or Token Holder has any concerns regarding a breach under this Agreement, the complaining 

party must first notify the other and allow the other party at least 30 days to remedy the claimed breach. Binding Arbitration. Any 

dispute arising out of or relating to this Agreement, or the breach thereof, shall finally settled under the Rules of Arbitration of 

the International Chamber of Commerce by one or three arbitrator, and judgement upon the award rendered the arbitrators may be 

entered in a court in United States jurisdiction. The arbitration will be conducted in the English language, in accordance with the 

international Arbitration Rules of the United States Commercial Arbitration Board. 

14. MISCELLANEOUS.

14.1. No Conditions to Effectiveness; Entire Agreement. There are no conditions to the effectiveness of this Agreement. This Agreement 

contains the entire agreement and understanding of the Parties hereto, and supersedes any prior agreements or understandings between 

or among the Parties hereto, which respect to the subject matter hereof. 

14.2. Governing Law. This Agreement, and the right of the Parties hereto, shall be governed by, construed and enforced in accordance 

with the laws of United States regardless of the conflict of laws principle. Any action in respect of, or concerning, this Agreement 

shall be litigated solely in United States and both Parties consent to jurisdiction of the person and venue solely in United States . 

14.3. Amendment and Waivers. This Agreement may be amended only by an instrument in writing signed by the Parties hereto. No waivers 

of or exceptions to any term, condition or provision of this Agreement, in any one or more instances, shall be deemed to be, or 

construed as, a further or continuing waiver of any such term, condition or provision. 

14.4. Severability. If any provision of this Agreement is held to be invalid or unenforceable, the validity and enforceability of the 

remaining provisions of this Agreement shall not be affected thereby. 

14.5. Each party, in entering into this Agreement, acts as an independent party and nothing herein shall be construed to create a 

partnership or joint venture between the Parties or to constitute agency of an sort. Neither party shall have the authority to bind the other. 

14.6. Force Majeure. A party is not liable for failure to perform the party’s obligations if such failure is as a result of Acts of 

God including: fire, flood, earthquake, storm, hurricane or other natural disaster), war, invasion, act of foreign enemies, 

hostilities (regardless of whether war is declared), civil war, rebellion, revolution, insurrection, military or usurped power or 

confiscation, terrorist activities, nationalization, government sanction, or government prohibition or regulation preventing the 

trade of blockchain-backed token(s). 

IN WITNESS WHEREOF, the Token Issuer, Qwoyn Digital Investments, LLC hereto have executed this Agreement as of the date first written 

above. 

Token Issuer/Token Holder

Daniel Pittman, CEO
_____________________________ 
Qwoyn Digital Investments, LLC 
2017-12-06                                                                                                                          */


/********************
 * SMART CONTRACT   *
 * CODE BEGINS HERE *
 *******************/ 

/*ERC20*/         
pragma solidity ^0.4.18;
 
//TOKEN SECURITY//
 
 /**
 * @title Math
 * @dev Assorted math operations
 */

library Math {
  function max64(uint64 a, uint64 b) internal pure returns (uint64) {
    return a >= b ? a : b;
  }

  function min64(uint64 a, uint64 b) internal pure returns (uint64) {
    return a < b ? a : b;
  }

  function max256(uint256 a, uint256 b) internal pure returns (uint256) {
    return a >= b ? a : b;
  }

  function min256(uint256 a, uint256 b) internal pure returns (uint256) {
    return a < b ? a : b;
  }
}
 
 /**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}
 
 /*
 * @title MerkleProof
 * @dev Merkle proof verification
 * @note Based on https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol
 */
library MerkleProof {
  /*
   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves
   * and each pair of pre-images is sorted.
   * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree
   * @param _root Merkle root
   * @param _leaf Leaf of Merkle tree
   */
  function verifyProof(bytes _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {
    // Check if proof length is a multiple of 32
    if (_proof.length % 32 != 0) return false;

    bytes32 proofElement;
    bytes32 computedHash = _leaf;

    for (uint256 i = 32; i <= _proof.length; i += 32) {
      assembly {
        // Load the current element of the proof
        proofElement := mload(add(_proof, i))
      }

      if (computedHash < proofElement) {
        // Hash(current computed hash + current element of the proof)
        computedHash = keccak256(computedHash, proofElement);
      } else {
        // Hash(current element of the proof + current computed hash)
        computedHash = keccak256(proofElement, computedHash);
      }
    }

    // Check if the computed hash (root) is equal to the provided root
    return computedHash == _root;
  }
}

 /**
 * @title Helps contracts guard agains rentrancy attacks.
 * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="3042555d535f7002401e535f5d">[email protected]</span>>
 * @notice If you mark a function `nonReentrant`, you should also
 * mark it `external`.
 */
contract ReentrancyGuard {

  /**
   * @dev We use a single lock for the whole contract.
   */
  bool private rentrancy_lock = false;

  /**
   * @dev Prevents a contract from calling itself, directly or indirectly.
   * @notice If you mark a function `nonReentrant`, you should also
   * mark it `external`. Calling one nonReentrant function from
   * another is not supported. Instead, you can implement a
   * `private` function doing the actual work, and a `external`
   * wrapper marked as `nonReentrant`.
   */
  modifier nonReentrant() {
    require(!rentrancy_lock);
    rentrancy_lock = true;
    _;
    rentrancy_lock = false;
  }

}

//Cornerstone TOKEN//

/*Contract to Declare Owner*/
contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}

/* Interfaces */
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }

//Cornerstone Contract//

/* Cornerstone Token Contract */
contract Cornerstone is owned{
    // Public variables of the token
    string public name;
    string public symbol;
    uint8 public decimals;
    // 18 decimals is the strongly suggested default, avoid changing it
    uint256 public totalSupply;

    // This creates an array with all balances
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;
    
    // This creates an arroy for accounts to freeze
    mapping (address => bool) public frozenAccount;

    // This generates a public event on the blockchain that will notify clients
    event Transfer(address indexed from, address indexed to, uint256 value);

    // This notifies clients about the amount burnt
    event Burn(address indexed from, uint256 value);
    
    // This notifies clients of frozen account
    event FrozenFunds(address target, bool frozen);

    /**
     * Constrctor function
     *
     * Initializes contract with initial supply tokens to the creator of the contract
     */
    function Cornerstone(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
    
    function freezeAccount(address target, bool freeze) onlyOwner public{
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
    
    /**
     * Internal transfer, only can be called by this contract
     */
    function _transfer(address _from, address _to, uint _value) internal {
        // Prevent transfer to 0x0 address. Use burn() instead
        require(_to != 0x0);
        // Check if the sender has enough
        require(balanceOf[_from] >= _value);
        // Check for overflows
        require(balanceOf[_to] + _value > balanceOf[_to]);
        // Save this for an assertion in the future
        // Check if sender is frozen
        require(!frozenAccount[_from]);        
        // Check if recipient is frozen
        require(!frozenAccount[_to]);                      
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        // Subtract from the sender
        balanceOf[_from] -= _value;
        // Add the same to the recipient
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        // Asserts are used to use static analysis to find bugs in your code. They should never fail
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    /**
     * Transfer tokens
     *
     * Send `_value` tokens to `_to` from your account
     *
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * Transfer tokens from other address
     *
     * Send `_value` tokens to `_to` in behalf of `_from`
     *
     * @param _from The address of the sender
     * @param _to The address of the recipient
     * @param _value the amount to send
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * Set allowance for other address
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     */
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * Set allowance for other address and notify
     *
     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
     *
     * @param _spender The address authorized to spend
     * @param _value the max amount they can spend
     * @param _extraData some extra information to send to the approved contract
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    /**
     * Destroy tokens
     *
     * Remove `_value` tokens from the system irreversibly
     *
     * @param _value the amount of money to burn
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
        balanceOf[msg.sender] -= _value;            // Subtract from the sender
        totalSupply -= _value;                      // Updates totalSupply
        Burn(msg.sender, _value);
        return true;
    }

    /**
     * Destroy tokens from other account
     *
     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
     *
     * @param _from the address of the sender
     * @param _value the amount of money to burn
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
        require(_value <= allowance[_from][msg.sender]);    // Check allowance
        balanceOf[_from] -= _value;                         // Subtract from the targeted balance
        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
        totalSupply -= _value;                              // Update totalSupply
        Burn(_from, _value);
        return true;
    }
}

/* ADVANCED TOKEN  */

contract MyAdvancedToken is owned, Cornerstone {

    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address => bool) public frozenAccount;

    /* This generates a public event on the blockchain that will notify clients */
    event FrozenFunds(address target, bool frozen);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    function MyAdvancedToken(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) Cornerstone(initialSupply, tokenName, tokenSymbol) public {}

    /* Internal transfer, only can be called by this contract */
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
        require (balanceOf[_from] >= _value);               // Check if the sender has enough
        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        require(!frozenAccount[_to]);                       // Check if recipient is frozen
        balanceOf[_from] -= _value;                         // Subtract from the sender
        balanceOf[_to] += _value;                           // Add the same to the recipient
        Transfer(_from, _to, _value);
    }

    /// @notice Create `mintedAmount` tokens and send it to `target`
    /// @param target Address to receive the tokens
    /// @param mintedAmount the amount of tokens it will receive
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
    /// @param target Address to be frozen
    /// @param freeze either to freeze it or not
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }

    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
    /// @param newSellPrice Price the users can sell to the contract
    /// @param newBuyPrice Price users can buy from the contract
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    /// @notice Buy tokens from contract by sending ether
    function buy() payable public {
        uint amount = msg.value / buyPrice;               // calculates the amount
        _transfer(this, msg.sender, amount);              // makes the transfers
    }

    /// @notice Sell `amount` tokens to contract
    /// @param amount amount of tokens to be sold
    function sell(uint256 amount) public {
        require(this.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy
        _transfer(msg.sender, this, amount);              // makes the transfers
        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
    }
}